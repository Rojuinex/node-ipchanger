// Generated by CoffeeScript 1.6.2
var ProxyServer, colors, config, currentProxy, db, hideMyAssGrabber, http, httpProxy, jsdom, lastChange, mongoose, net, prop, qs, server, setupDatabase, setupGrabbers, startServer, updateProxy, util;

colors = require('./colors');

for (prop in colors) {
  eval(prop + ' = colors[prop]');
}

http = require('http');

httpProxy = require('http-proxy');

qs = require('querystring');

jsdom = require('jsdom');

util = require('util');

mongoose = require('mongoose');

hideMyAssGrabber = require('./proxyGrabbers/hidemyass');

config = require('../config.json');

net = require('net');

util = require('util');

lastChange = null;

currentProxy = null;

mongoose.connect('mongodb://localhost/ipchanger');

db = mongoose.connection;

db.on('error', console.error.bind(console, 'connection error:'));

ProxyServer = null;

setupDatabase = function(cb) {
  var proxyServerSchema;

  proxyServerSchema = mongoose.Schema({
    'Last-Update': String,
    'ipaddress': String,
    'port': Number,
    'country': String,
    'speed': Number,
    'connectionTime': Number,
    'ping': {
      'type': Number,
      'default': -1
    },
    'from': String,
    'type': String,
    'annon': String,
    'last-used': {
      'type': Date,
      'default': new Date()
    },
    'last-durration': {
      'type': Number,
      'default': 0
    }
  });
  proxyServerSchema.methods.pingServer = function() {};
  ProxyServer = mongoose.model('ProxyServer', proxyServerSchema);
  if (cb !== null && typeof cb === "function") {
    return cb();
  }
};

setupGrabbers = function() {
  hideMyAssGrabber.setup(ProxyServer, db, mongoose);
  hideMyAssGrabber.setUpdateInterval(config.updateInterval);
  hideMyAssGrabber.autoUpdate(true);
  return hideMyAssGrabber.update();
};

db.once('open', function() {
  return setupDatabase(function() {
    setupGrabbers();
    updateProxy();
    return startServer();
  });
});

server = http.createServer(function(req, res) {
  req.on('data', function(data) {});
  return req.on('end', function() {
    res.writeHead(200, {
      "Content-Type": "text/plain"
    });
    res.write("Current proxy grabbers: \n\tHide My Ass\tDomain: hidemyass.com\tLast Updated: " + (hideMyAssGrabber.lastUpdated()) + "\tNext Update: " + (hideMyAssGrabber.nextUpdate()) + "\n");
    res.write("\nServers in database: \n");
    return ProxyServer.find(function(err, servers) {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = servers.length; _i < _len; _i++) {
        server = servers[_i];
        if (_i > 0) {
          res.write('\n\n');
        }
        res.write('Server ' + _i);
        res.write('\n\t' + 'Last-Update     ' + server['Last-Update']);
        res.write('\n\t' + 'ipaddress       ' + server['ipaddress']);
        res.write('\n\t' + 'port            ' + server['port']);
        res.write('\n\t' + 'country         ' + server['country']);
        res.write('\n\t' + 'speed           ' + server['speed']);
        res.write('\n\t' + 'connectionTime  ' + server['connectionTime']);
        res.write('\n\t' + 'ping            ' + server['ping']);
        res.write('\n\t' + 'from            ' + server['from']);
        res.write('\n\t' + 'type            ' + server['type']);
        res.write('\n\t' + 'annon           ' + server['annon']);
        res.write('\n\t' + 'last-used       ' + server['last-used']);
        res.write('\n\t' + 'last-durration  ' + server['last-durration']);
        if (_i === _len) {
          _results.push(res.end("****************************************\n          No More Proxy Servers\n****************************************\n"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });
});

updateProxy = function() {
  return ProxyServer.find().sort("speed").exec(function(err, servers) {
    var _i, _len;

    if (err) {
      logX(red, err);
    }
    for (_i = 0, _len = servers.length; _i < _len; _i++) {
      server = servers[_i];
      if (server["last-durration"] < config['max-time'] || server["last-used"].getTime() < Date.now() - config['reset-time']) {
        logX(ltYellow, "Now using proxy server " + server.ipaddress + " on port " + server.port + " with speed " + server.speed + "!");
        if (currentProxy !== null && lastChange !== null) {
          currentProxy["last-used"] = lastChange;
          currentProxy["last-durration"] = Date.now() - lastChange.getTime();
          currentProxy.save(function(err) {
            if (err) {
              return console.error(err);
            }
          });
        }
        lastChange = new Date();
        currentProxy = server;
        return;
      }
    }
  });
};

startServer = function() {
  var forwardServer;

  logX(bgGreen + black, "\t\t\t\t\t\t\tStarting Server\t\t\t\t\t\t\t");
  logX(ltGreen, "Running on port " + config['http-port'] + "\n");
  server.listen(config['http-port']);
  forwardServer = net.createServer(function(clientSocket) {
    var buffers, connected, proxySocket;

    connected = false;
    buffers = new Array();
    proxySocket = new net.Socket();
    proxySocket.connect(currentProxy.port, currentProxy.ipaddress, function() {
      var buffer, _i, _len, _results;

      logX(ltYellow, "Connected to proxy 108.41.35.10 21858");
      connected = true;
      if (buffers.length > 0) {
        _results = [];
        for (_i = 0, _len = buffers.length; _i < _len; _i++) {
          buffer = buffers[_i];
          _results.push(proxySocket.write(buffer));
        }
        return _results;
      }
    });
    clientSocket.on('error', function(e) {
      console.log(red + "client socekt error");
      console.error(e);
      console.log(reset);
      return proxySocket.end();
    });
    proxySocket.on('error', function(e) {
      console.log(red + "proxy socket error");
      console.error(e);
      console.log(reset);
      return clientSocket.end();
    });
    proxySocket.on('data', function(data) {
      return clientSocket.write(data);
    });
    proxySocket.on('end', function() {
      return clientSocket.end();
    });
    clientSocket.on('end', function() {
      return clientSocket.end();
    });
    clientSocket.on('data', function(data) {
      if (connected) {
        return proxySocket.write(data);
      } else {
        return buffers[buffers.length] = data;
      }
    });
    clientSocket.on('close', function(did_error) {
      return proxySocket.end();
    });
    return proxySocket.on('close', function(did_error) {
      return clientSocket.end();
    });
  });
  forwardServer.listen(config['proxy-port'], function() {
    return logX(bgGreen + black, "Forward server bound on port " + config['proxy-port']);
  });
  return setInterval(function() {
    logX(ltRed, "rotating");
    return updateProxy();
  }, config['rotateInterval']);
};
