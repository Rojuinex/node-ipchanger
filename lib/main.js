// Generated by CoffeeScript 1.6.2
var ProxyServer, colors, config, currentProxy, db, hideMyAssGrabber, http, httpProxy, jsdom, lastChange, mongoose, net, prop, qs, server, setupDatabase, setupGrabbers, startServer, updateProxy, util;

colors = require('./colors');

for (prop in colors) {
  eval(prop + ' = colors[prop]');
}

http = require('http');

httpProxy = require('http-proxy');

qs = require('querystring');

jsdom = require('jsdom');

util = require('util');

mongoose = require('mongoose');

hideMyAssGrabber = require('./proxyGrabbers/hidemyass');

config = require('../config.json');

net = require('net');

util = require('util');

lastChange = null;

currentProxy = null;

mongoose.connect('mongodb://localhost/ipchanger');

db = mongoose.connection;

db.on('error', console.error.bind(console, 'connection error:'));

ProxyServer = null;

setupDatabase = function(cb) {
  var proxyServerSchema;

  proxyServerSchema = mongoose.Schema({
    'Last-Update': String,
    'ipaddress': String,
    'port': Number,
    'country': String,
    'speed': Number,
    'connectionTime': Number,
    'ping': {
      'type': Number,
      'default': -1
    },
    'from': String,
    'type': String,
    'annon': String,
    'last-used': {
      'type': Date,
      'default': 0
    },
    'last-duration': {
      'type': Number,
      'default': 0
    }
  });
  proxyServerSchema.methods.pingServer = function() {};
  ProxyServer = mongoose.model('ProxyServer', proxyServerSchema);
  if (cb !== null && typeof cb === "function") {
    return cb();
  }
};

setupGrabbers = function() {
  hideMyAssGrabber.setup(ProxyServer, db, mongoose);
  hideMyAssGrabber.setUpdateInterval(config.updateInterval);
  hideMyAssGrabber.autoUpdate(true);
  return hideMyAssGrabber.update();
};

db.once('open', function() {
  return setupDatabase(function() {
    setupGrabbers();
    updateProxy();
    return startServer();
  });
});

server = http.createServer(function(req, res) {
  req.on('data', function(data) {});
  return req.on('end', function() {
    res.writeHead(200, {
      "Content-Type": "text/plain"
    });
    res.write("Current proxy grabbers: \n\tHide My Ass\tDomain: hidemyass.com\tLast Updated: " + (hideMyAssGrabber.lastUpdated()) + "\tNext Update: " + (hideMyAssGrabber.nextUpdate()) + "\n");
    res.write("\nServers in database: \n");
    return ProxyServer.find(function(err, servers) {
      var _i, _len, _results;

      _results = [];
      for (_i = 0, _len = servers.length; _i < _len; _i++) {
        server = servers[_i];
        if (_i > 0) {
          res.write('\n\n');
        }
        res.write('Server ' + _i);
        res.write('\n\t' + 'Last-Update     ' + server['Last-Update']);
        res.write('\n\t' + 'ipaddress       ' + server['ipaddress']);
        res.write('\n\t' + 'port            ' + server['port']);
        res.write('\n\t' + 'country         ' + server['country']);
        res.write('\n\t' + 'speed           ' + server['speed']);
        res.write('\n\t' + 'connectionTime  ' + server['connectionTime']);
        res.write('\n\t' + 'ping            ' + server['ping']);
        res.write('\n\t' + 'from            ' + server['from']);
        res.write('\n\t' + 'type            ' + server['type']);
        res.write('\n\t' + 'annon           ' + server['annon']);
        res.write('\n\t' + 'last-used       ' + server['last-used']);
        res.write('\n\t' + 'last-duration  ' + server['last-duration']);
        if (_i === _len) {
          _results.push(res.end("****************************************\n          No More Proxy Servers\n****************************************\n"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });
});

updateProxy = function() {
  var findNext;

  findNext = function() {
    return ProxyServer.find().sort("speed").exec(function(err, servers) {
      var _i, _len;

      if (err) {
        logX(red, err);
      }
      if (servers === null || servers.length <= 0) {
        setTimeout(findNext, 1000);
      }
      for (_i = 0, _len = servers.length; _i < _len; _i++) {
        server = servers[_i];
        if (currentProxy !== null && server.ipaddress === currentProxy.ipaddress) {
          continue;
        }
        if (config.loglevel.verbose) {
          logX(blue, "\ntrying server " + server.ipaddress + ":" + server.port);
        }
        if (server["last-duration"] < config['max-time'] || server["last-used"].getTime() < Date.now() - config['reset-time']) {
          logX(ltYellow, "Now using proxy server " + server.ipaddress + " on port " + server.port + " with speed " + server.speed + "!");
          if (config.loglevel.verbose) {
            logX(blue, "Selected because last duration " + (server["last-duration"] < config['max-time']) + " Reset Time passed " + (server["last-used"].getTime() < Date.now() - config['reset-time']));
          }
          logX(blue, "\tLast Duration " + server['last-duration'] + "\n\tLast Used " + (server["last-used"].getTime()));
          lastChange = new Date();
          currentProxy = server;
          return;
        } else {
          if (config.loglevel.verbose) {
            logX(blue, "server " + server.ipaddress + ":" + server.port + " disqualified because");
          }
          if (server["last-duration"] >= config['max-time'] && config.loglevel.verbose) {
            logX(blue, "\tLast Duration (" + server['last-duration'] + ") > Max Time (" + config['max-time'] + ")");
          }
          if (server["last-used"].getTime() >= Date.now() - config['reset-time'] && config.loglevel.verbose) {
            logX(blue, "\tLast Used (" + (server['last-used'].getTime()) + ") > Now (" + (Date.now()) + ") - reset time (" + config['reset-time'] + ")");
          }
          console.log("");
        }
      }
    });
  };
  if (currentProxy !== null && lastChange !== null) {
    currentProxy["last-used"] = lastChange;
    currentProxy["last-duration"] = config["max-time"];
    return currentProxy.save(function(err) {
      if (err) {
        console.error(err);
      }
      if (config.loglevel.verbose) {
        logX(blue, "Saved " + currentProxy.ipaddress + " ");
      }
      return findNext();
    });
  } else {
    return findNext();
  }
};

startServer = function() {
  var forwardServer;

  logX(bgGreen + black, "\t\t\t\t\t\t\tStarting Server\t\t\t\t\t\t\t");
  logX(ltGreen, "Running on port " + config['http-port'] + "\n");
  server.listen(config['http-port']);
  forwardServer = net.createServer(function(clientSocket) {
    var buffers, connected, proxySocket;

    connected = false;
    buffers = new Array();
    proxySocket = new net.Socket();
    proxySocket.connect(currentProxy.port, currentProxy.ipaddress, function() {
      var buffer, _i, _len, _results;

      connected = true;
      if (buffers.length > 0) {
        _results = [];
        for (_i = 0, _len = buffers.length; _i < _len; _i++) {
          buffer = buffers[_i];
          _results.push(proxySocket.write(buffer));
        }
        return _results;
      }
    });
    clientSocket.on('error', function(e) {
      console.log(red + "client socekt error");
      console.error(e);
      console.log(reset);
      return proxySocket.end();
    });
    proxySocket.on('error', function(e) {
      console.log(red + "proxy socket error");
      console.error(e);
      console.log(reset);
      return clientSocket.end();
    });
    proxySocket.on('data', function(data) {
      return clientSocket.write(data);
    });
    proxySocket.on('end', function() {
      return clientSocket.end();
    });
    clientSocket.on('end', function() {
      return clientSocket.end();
    });
    clientSocket.on('data', function(data) {
      if (connected) {
        return proxySocket.write(data);
      } else {
        return buffers[buffers.length] = data;
      }
    });
    clientSocket.on('close', function(did_error) {
      return proxySocket.end();
    });
    return proxySocket.on('close', function(did_error) {
      return clientSocket.end();
    });
  });
  forwardServer.listen(config['proxy-port'], function() {
    return logX(bgGreen + black, "Forward server bound on port " + config['proxy-port']);
  });
  return setInterval(function() {
    return updateProxy();
  }, config['rotateInterval']);
};
