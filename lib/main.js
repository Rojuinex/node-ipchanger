// Generated by CoffeeScript 1.6.2
var ProxyServer, app, blacklist, colors, config, connResetCounter, currentProxy, db, express, forwardServer, fs, hideMyAssGrabber, http, httpServer, jsdom, lastChange, mongoose, net, portscanner, prop, proxyServerStarted, qs, setupDatabase, setupGrabbers, startProxyServer, startServer, updateProxy, updating, util;

Array.prototype["in"] = function(item) {
  var val, _i, _len;

  for (_i = 0, _len = this.length; _i < _len; _i++) {
    val = this[_i];
    if (val === item) {
      return true;
    }
    if (_i + 1 === _len) {
      return false;
    }
  }
};

colors = require('./colors');

for (prop in colors) {
  eval(prop + ' = colors[prop]');
}

process.on('uncaughtException', function(err) {
  errorX(red, "Uncaught error!!!");
  return errorX(red, err.stack);
});

http = require('http');

qs = require('querystring');

fs = require('fs');

jsdom = require('jsdom');

util = require('util');

mongoose = require('mongoose');

hideMyAssGrabber = require('./proxyGrabbers/hidemyass');

config = require(__dirname + '/../config.json');

blacklist = require(__dirname + '/../blacklist.json');

net = require('net');

portscanner = require('portscanner');

express = require('express');

fs.watch(__dirname + '/../config.json', {
  persistent: false,
  interval: 1000
}, function(event, filename) {
  var name;

  if (event === 'change') {
    logX(magenta, "Configuration file changed!  Loading changes...");
    name = require.resolve(__dirname + '/../config.json');
    delete require.cache[name];
    return config = require(__dirname + '/../config.json');
  }
});

fs.watch(__dirname + '/../blacklist.json', {
  persistent: false,
  interval: 1000
}, function(event, filename) {
  var name;

  if (event === 'change') {
    logX(magenta, "Blacklist file changed!  Loading changes...");
    name = require.resolve(__dirname + '/../blacklist.json');
    delete require.cache[name];
    return blacklist = require(__dirname + '/../blacklist.json');
  }
});

lastChange = null;

currentProxy = null;

proxyServerStarted = false;

forwardServer = null;

connResetCounter = 0;

mongoose.connect('mongodb://localhost/ipchanger');

db = mongoose.connection;

db.on('error', console.error.bind(console, new Date() + '\nconnection error:'));

ProxyServer = null;

setupDatabase = function(cb) {
  var proxyServerSchema;

  proxyServerSchema = mongoose.Schema({
    'Last-Update': String,
    'ipaddress': String,
    'port': Number,
    'country': String,
    'speed': Number,
    'connectionTime': Number,
    'ping': {
      'type': Number,
      'default': -1
    },
    'from': String,
    'type': String,
    'annon': String,
    'last-used': {
      'type': Date,
      'default': 0
    },
    'last-duration': {
      'type': Number,
      'default': 0
    }
  });
  proxyServerSchema.methods.pingServer = function() {};
  ProxyServer = mongoose.model('ProxyServer', proxyServerSchema);
  if (cb !== null && typeof cb === "function") {
    return cb();
  }
};

setupGrabbers = function() {
  hideMyAssGrabber.setup(ProxyServer, db, mongoose);
  return hideMyAssGrabber.update(function() {
    return setTimeout(updateProxy, 1000);
  });
};

db.once('open', function() {
  return setupDatabase(function() {
    startServer();
    return updateProxy();
  });
});

updating = false;

updateProxy = function() {
  var checkPort, checkProxy, findNext, foundProxy, getServers, index;

  if (updating) {
    return;
  }
  updating = true;
  foundProxy = false;
  logX(bgBlue + ltYellow, "Updating proxy...                        ");
  checkPort = function(server, cb) {
    return portscanner.checkPortStatus(server.port, server.ipaddress, function(error, status) {
      if (error) {
        errorX(red, error);
      }
      if (config.loglevel.verbose) {
        logX(cyan, "Status of " + server.ipaddress + ":" + server.port + " is " + status);
      }
      if ((cb != null) && typeof cb === 'function') {
        return cb(status);
      } else {
        return logX(cyan, "no callback... Status of " + server.ipaddress + ":" + server.port + " is " + status);
      }
    });
  };
  checkProxy = function(server, cb) {
    var connected, proxySocket, timeOutFunction;

    timeOutFunction = null;
    proxySocket = new net.Socket();
    connected = false;
    proxySocket.connect(server.port, server.ipaddress, function() {
      return connected = true;
    });
    proxySocket.on('error', function(e) {
      if (e.code === "ECONNREFUSED") {
        server['last-duration'] = config['max-time'];
        server['last-used'] = Date.now();
        server.save(function(err) {
          if (err) {
            return errorX(red, "Save error " + err);
          }
        });
        logX(ltYellow, "Server " + server.ipaddress + ":" + server.port + " not active!");
        if (!connected && !foundProxy) {
          return cb(false);
        }
      } else {
        return errorX(red, "Check Proxy error " + e.stack);
      }
    });
    proxySocket.on('connect', function() {
      if (config.loglevel.verbose) {
        logX(cyan, "connected to proxy " + server.ipaddress + ":" + server.port);
      }
      connected = true;
      foundProxy = true;
      cb(true);
      if (timeOutFunction !== null) {
        clearTimeout(timeOutFunction);
      }
      return proxySocket.end();
    });
    return timeOutFunction = setTimeout(function() {
      if (!connected) {
        proxySocket.end();
        return cb(false);
      }
    }, 5000);
  };
  index = 0;
  findNext = function(servers) {
    var len, server;

    if (foundProxy) {
      return;
    }
    len = servers.len;
    if (index === len) {
      index = 0;
    }
    server = servers[index++];
    if (currentProxy !== null && server.ipaddress === currentProxy.ipaddress) {
      return findNext(servers, index);
    }
    if (blacklist["in"](server.ipaddress)) {
      logX(bgRed + black, "Server " + server.ipaddress + " is blacklisted!");
      return findNext(servers, index);
    }
    if (config.loglevel.verbose) {
      logX(cyan, "trying server " + server.ipaddress + ":" + server.port);
    }
    if (server["last-duration"] < config['max-time'] || server["last-used"].getTime() < Date.now() - config['reset-time']) {
      return checkPort(server, function(status) {
        if (status === 'open') {
          return checkProxy(server, function(active) {
            if (active) {
              logX(ltYellow, "Now using proxy server " + server.ipaddress + " on port " + server.port + " with speed " + server.speed + "!");
              if (config.loglevel.verbose) {
                logX(cyan, "Selected because last duration " + (server["last-duration"] < config['max-time']) + " Reset Time passed " + (server["last-used"].getTime() < Date.now() - config['reset-time']));
                logX(cyan, "\tLast Duration " + server['last-duration']);
                logX(cyan, "\tLast Used " + (server["last-used"].getTime()));
              }
              lastChange = new Date();
              currentProxy = server;
              updating = false;
              if (!proxyServerStarted) {
                return startProxyServer();
              }
            } else {
              return findNext(servers);
            }
          });
        } else {
          return findNext(servers);
        }
      });
    } else {
      if (config.loglevel.verbose) {
        logX(cyan, "server " + server.ipaddress + ":" + server.port + " disqualified because");
      }
      if ((server["last-duration"] >= config['max-time']) && config.loglevel.verbose) {
        logX(cyan, "\tLast Duration (" + server['last-duration'] + ") > Max Time (" + config['max-time'] + ")");
      }
      if ((server["last-used"].getTime() >= Date.now() - config['reset-time']) && config.loglevel.verbose) {
        logX(cyan, "\tLast Used (" + (server['last-used'].getTime()) + ") > Now (" + (Date.now()) + ") - reset time (" + config['reset-time'] + ")");
      }
      return findNext(servers);
    }
  };
  getServers = function() {
    return ProxyServer.find().sort("speed").exec(function(err, servers) {
      if (err) {
        logX(red, err);
      }
      if (servers === null || servers.length <= 0) {
        return setTimeout(getServers, 1000);
      } else {
        return findNext(servers);
      }
    });
  };
  if (currentProxy !== null && lastChange !== null) {
    currentProxy["last-used"] = lastChange;
    currentProxy["last-duration"] = config["max-time"];
    return currentProxy.save(function(err) {
      if (err) {
        errorX(err);
      }
      return getServers();
    });
  } else {
    return getServers();
  }
};

httpServer = http.createServer(function(req, res) {
  req.on('data', function(data) {});
  return req.on('end', function() {
    res.writeHead(200, {
      "Content-Type": "text/plain"
    });
    res.write("Proxy server running " + proxyServerStarted + "\n");
    if (proxyServerStarted) {
      res.write("\ton port" + config['proxy-port'] + "\n");
    }
    res.write("Current proxy grabbers: \n\tHide My Ass\tDomain: hidemyass.com\tLast Updated: " + (hideMyAssGrabber.lastUpdated()) + "\tNext Update: " + (hideMyAssGrabber.nextUpdate()) + "\n");
    res.write("\nServers in database: \n");
    return ProxyServer.find(function(err, servers) {
      var server, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = servers.length; _i < _len; _i++) {
        server = servers[_i];
        if (_i > 0) {
          res.write('\n\n');
        }
        res.write('Server ' + _i);
        res.write('\n\t' + 'Last-Update     ' + server['Last-Update']);
        res.write('\n\t' + 'ipaddress       ' + server['ipaddress']);
        res.write('\n\t' + 'port            ' + server['port']);
        res.write('\n\t' + 'country         ' + server['country']);
        res.write('\n\t' + 'speed           ' + server['speed']);
        res.write('\n\t' + 'connectionTime  ' + server['connectionTime']);
        res.write('\n\t' + 'ping            ' + server['ping']);
        res.write('\n\t' + 'from            ' + server['from']);
        res.write('\n\t' + 'type            ' + server['type']);
        res.write('\n\t' + 'annon           ' + server['annon']);
        res.write('\n\t' + 'last-used       ' + server['last-used']);
        res.write('\n\t' + 'last-duration  ' + server['last-duration']);
        if (_i === _len) {
          _results.push(res.end("****************************************\n          No More Proxy Servers\n****************************************\n"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });
});

startServer = function() {
  logX(bgGreen + black, "\t\t\t\t\t\tStarting Web Server\t\t\t\t\t\t\t");
  logX(ltGreen, "Web server running on port " + config['http-port']);
  return httpServer.listen(config['http-port']);
};

startProxyServer = function() {
  logX(bgGreen + black, "\t\t\t\t\t\tStarting Proxy Server\t\t\t\t\t\t\t");
  proxyServerStarted = true;
  forwardServer = net.createServer(function(clientSocket) {
    var buffers, changing, closed, connected, proxySocket;

    connected = false;
    changing = false;
    closed = false;
    buffers = new Array();
    proxySocket = new net.Socket();
    proxySocket.connect(currentProxy.port, currentProxy.ipaddress, function() {
      var buffer, _i, _len, _results;

      connected = true;
      changing = false;
      if (buffers.length > 0) {
        _results = [];
        for (_i = 0, _len = buffers.length; _i < _len; _i++) {
          buffer = buffers[_i];
          _results.push(proxySocket.write(buffer));
        }
        return _results;
      }
    });
    clientSocket.on('error', function(e) {
      errorX(red, "client socket error");
      return errorX(red, e);
    });
    proxySocket.on('error', function(e) {
      if (e.code === "ECONNREFUSED") {
        logX(red + "Connection Refused... trying new server");
        if (!changing) {
          changing = true;
          updateProxy();
        }
      }
      /*
      			else if e.code is "ECONNRESET"
      				connected = false
      				connResetCounter++
      				if connResetCounter >= 10
      					connResetCounter = 0
      					if !changing
      						changing = true
      						updateProxy()	
      				else
      					proxySocket.connect currentProxy.port, currentProxy.ipaddress, ()->
      						connected = true
      						changing  = false
      						if buffers.length > 0
      							for buffer in buffers
      								proxySocket.write buffer
      */

      errorX(red, "proxy socket error");
      return errorX(red, e);
    });
    proxySocket.on('data', function(data) {
      return clientSocket.write(data);
    });
    clientSocket.on('data', function(data) {
      buffers[buffers.length] = data;
      if (connected && !closed) {
        return proxySocket.write(data);
      }
    });
    clientSocket.on('close', function(did_error) {
      return proxySocket.end();
    });
    return proxySocket.on('close', function(did_error) {
      closed = true;
      return clientSocket.end();
    });
  });
  forwardServer.listen(config['proxy-port'], function() {
    return logX(ltGreen, "Proxy server bound on port " + config['proxy-port']);
  });
  return setInterval(function() {
    return hideMyAssGrabber.update(updateProxy);
  }, config['rotateInterval']);
};

app = express();

app.set('view engine', 'jade');

app.set('views', __dirname + '/../views');

app.use(express.cookieParser('Cookie4Xi3'));

app.use(express.session({
  key: 'ipconfig.key'
}));

app.use(express.basicAuth(function(user, pass) {
  return user === config.administrator.username && pass === config.administrator.password;
}));

app.get('/', function(req, res) {
  return res.render('index');
});

app.get('/logout', function(req, res) {
  return res.redirect('http://forget:forget@localhost/');
});

app.listen(80);
