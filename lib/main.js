// Generated by CoffeeScript 1.6.2
var ProxyServer, colors, config, connResetCounter, currentProxy, db, forwardServer, hideMyAssGrabber, http, httpServer, jsdom, lastChange, mongoose, net, prop, proxyServerStarted, qs, setupDatabase, setupGrabbers, startProxyServer, startServer, updateProxy, updating, util;

colors = require('./colors');

for (prop in colors) {
  eval(prop + ' = colors[prop]');
}

process.on('uncaughtException', function(err) {
  errorX(red, "Uncaught error!!!");
  return errorX(red, err.stack);
});

http = require('http');

qs = require('querystring');

jsdom = require('jsdom');

util = require('util');

mongoose = require('mongoose');

hideMyAssGrabber = require('./proxyGrabbers/hidemyass');

config = require('../config.json');

net = require('net');

util = require('util');

lastChange = null;

currentProxy = null;

proxyServerStarted = false;

forwardServer = null;

connResetCounter = 0;

mongoose.connect('mongodb://localhost/ipchanger');

db = mongoose.connection;

db.on('error', console.error.bind(console, new Date() + '\nconnection error:'));

ProxyServer = null;

setupDatabase = function(cb) {
  var proxyServerSchema;

  proxyServerSchema = mongoose.Schema({
    'Last-Update': String,
    'ipaddress': String,
    'port': Number,
    'country': String,
    'speed': Number,
    'connectionTime': Number,
    'ping': {
      'type': Number,
      'default': -1
    },
    'from': String,
    'type': String,
    'annon': String,
    'last-used': {
      'type': Date,
      'default': 0
    },
    'last-duration': {
      'type': Number,
      'default': 0
    }
  });
  proxyServerSchema.methods.pingServer = function() {};
  ProxyServer = mongoose.model('ProxyServer', proxyServerSchema);
  if (cb !== null && typeof cb === "function") {
    return cb();
  }
};

setupGrabbers = function() {
  hideMyAssGrabber.setup(ProxyServer, db, mongoose);
  return hideMyAssGrabber.update(function() {
    return setTimeout(updateProxy, 1000);
  });
};

db.once('open', function() {
  return setupDatabase(function() {
    startServer();
    return setupGrabbers();
  });
});

updating = false;

updateProxy = function() {
  var checkProxy, findNext, foundProxy, getServers, index;

  if (updating) {
    return;
  }
  updating = true;
  foundProxy = false;
  logX(bgBlue + ltYellow, "Updating proxy...");
  checkProxy = function(server, cb) {
    var connected, proxySocket, timeOutFunction;

    timeOutFunction = null;
    proxySocket = new net.Socket();
    connected = false;
    proxySocket.connect(server.port, server.ipaddress, function() {
      return connected = true;
    });
    proxySocket.on('error', function(e) {
      if (e.code === "ECONNREFUSED") {
        server['last-duration'] = config['max-time'];
        server['last-used'] = Date.now();
        server.save(function(err) {
          if (err) {
            return errorX(red, "Save error " + err);
          }
        });
        logX(ltYellow, "Server " + server.ipaddress + ":" + server.port + " not active!");
        if (!connected && !foundProxy) {
          return cb(false);
        }
      } else {
        return errorX(red, "Check Proxy error " + e.stack);
      }
    });
    proxySocket.on('connect', function() {
      if (config.loglevel.verbose) {
        logX(blue, "connected to proxy " + server.ipaddress + ":" + server.port);
      }
      connected = true;
      foundProxy = true;
      cb(true);
      if (timeOutFunction !== null) {
        clearTimeout(timeOutFunction);
      }
      return proxySocket.end();
    });
    return timeOutFunction = setTimeout(function() {
      if (!connected) {
        proxySocket.end();
        return cb(false);
      }
    }, 5000);
  };
  index = 0;
  findNext = function(servers) {
    var len, server;

    if (foundProxy) {
      return;
    }
    len = servers.len;
    if (index === len) {
      index = 0;
    }
    server = servers[index++];
    if (currentProxy !== null && server.ipaddress === currentProxy.ipaddress) {
      return findNext(servers, index);
    }
    if (config.loglevel.verbose) {
      logX(blue, "trying server " + server.ipaddress + ":" + server.port);
    }
    if (server["last-duration"] < config['max-time'] || server["last-used"].getTime() < Date.now() - config['reset-time']) {
      return checkProxy(server, function(active) {
        if (active) {
          logX(ltYellow, "Now using proxy server " + server.ipaddress + " on port " + server.port + " with speed " + server.speed + "!");
          if (config.loglevel.verbose) {
            logX(blue, "Selected because last duration " + (server["last-duration"] < config['max-time']) + " Reset Time passed " + (server["last-used"].getTime() < Date.now() - config['reset-time']));
            logX(blue, "\tLast Duration " + server['last-duration']);
            logX(blue, "\tLast Used " + (server["last-used"].getTime()));
          }
          lastChange = new Date();
          currentProxy = server;
          updating = false;
          if (!proxyServerStarted) {
            return startProxyServer();
          }
        } else {
          return findNext(servers);
        }
      });
    } else {
      if (config.loglevel.verbose) {
        logX(blue, "server " + server.ipaddress + ":" + server.port + " disqualified because");
      }
      if ((server["last-duration"] >= config['max-time']) && config.loglevel.verbose) {
        logX(blue, "\tLast Duration (" + server['last-duration'] + ") > Max Time (" + config['max-time'] + ")");
      }
      if ((server["last-used"].getTime() >= Date.now() - config['reset-time']) && config.loglevel.verbose) {
        logX(blue, "\tLast Used (" + (server['last-used'].getTime()) + ") > Now (" + (Date.now()) + ") - reset time (" + config['reset-time'] + ")");
      }
      return findNext(servers);
    }
  };
  getServers = function() {
    return ProxyServer.find().sort("speed").exec(function(err, servers) {
      if (err) {
        logX(red, err);
      }
      if (servers === null || servers.length <= 0) {
        return setTimeout(getServers, 1000);
      } else {
        return findNext(servers);
      }
    });
  };
  if (currentProxy !== null && lastChange !== null) {
    currentProxy["last-used"] = lastChange;
    currentProxy["last-duration"] = config["max-time"];
    return currentProxy.save(function(err) {
      if (err) {
        errorX(err);
      }
      return getServers();
    });
  } else {
    return getServers();
  }
};

httpServer = http.createServer(function(req, res) {
  req.on('data', function(data) {});
  return req.on('end', function() {
    res.writeHead(200, {
      "Content-Type": "text/plain"
    });
    res.write("Proxy server running " + proxyServerStarted + "\n");
    if (proxyServerStarted) {
      res.write("\ton port" + config['proxy-port'] + "\n");
    }
    res.write("Current proxy grabbers: \n\tHide My Ass\tDomain: hidemyass.com\tLast Updated: " + (hideMyAssGrabber.lastUpdated()) + "\tNext Update: " + (hideMyAssGrabber.nextUpdate()) + "\n");
    res.write("\nServers in database: \n");
    return ProxyServer.find(function(err, servers) {
      var server, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = servers.length; _i < _len; _i++) {
        server = servers[_i];
        if (_i > 0) {
          res.write('\n\n');
        }
        res.write('Server ' + _i);
        res.write('\n\t' + 'Last-Update     ' + server['Last-Update']);
        res.write('\n\t' + 'ipaddress       ' + server['ipaddress']);
        res.write('\n\t' + 'port            ' + server['port']);
        res.write('\n\t' + 'country         ' + server['country']);
        res.write('\n\t' + 'speed           ' + server['speed']);
        res.write('\n\t' + 'connectionTime  ' + server['connectionTime']);
        res.write('\n\t' + 'ping            ' + server['ping']);
        res.write('\n\t' + 'from            ' + server['from']);
        res.write('\n\t' + 'type            ' + server['type']);
        res.write('\n\t' + 'annon           ' + server['annon']);
        res.write('\n\t' + 'last-used       ' + server['last-used']);
        res.write('\n\t' + 'last-duration  ' + server['last-duration']);
        if (_i === _len) {
          _results.push(res.end("****************************************\n          No More Proxy Servers\n****************************************\n"));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    });
  });
});

startServer = function() {
  logX(bgGreen + black, "\t\t\t\t\t\tStarting Web Server\t\t\t\t\t\t\t");
  logX(ltGreen, "Web server running on port " + config['http-port']);
  return httpServer.listen(config['http-port']);
};

startProxyServer = function() {
  logX(bgGreen + black, "\t\t\t\t\t\tStarting Proxy Server\t\t\t\t\t\t\t");
  proxyServerStarted = true;
  forwardServer = net.createServer(function(clientSocket) {
    var buffers, changing, closed, connected, proxySocket;

    connected = false;
    changing = false;
    closed = false;
    buffers = new Array();
    proxySocket = new net.Socket();
    proxySocket.connect(currentProxy.port, currentProxy.ipaddress, function() {
      var buffer, _i, _len, _results;

      connected = true;
      changing = false;
      if (buffers.length > 0) {
        _results = [];
        for (_i = 0, _len = buffers.length; _i < _len; _i++) {
          buffer = buffers[_i];
          _results.push(proxySocket.write(buffer));
        }
        return _results;
      }
    });
    clientSocket.on('error', function(e) {
      errorX(red, "client socket error");
      return errorX(red, e);
    });
    proxySocket.on('error', function(e) {
      if (e.code === "ECONNREFUSED") {
        logX(red + "Connection Refused... trying new server");
        if (!changing) {
          changing = true;
          updateProxy();
        }
      }
      /*
      			else if e.code is "ECONNRESET"
      				connected = false
      				connResetCounter++
      				if connResetCounter >= 10
      					connResetCounter = 0
      					if !changing
      						changing = true
      						updateProxy()	
      				else
      					proxySocket.connect currentProxy.port, currentProxy.ipaddress, ()->
      						connected = true
      						changing  = false
      						if buffers.length > 0
      							for buffer in buffers
      								proxySocket.write buffer
      */

      errorX(red, "proxy socket error");
      return errorX(red, e);
    });
    proxySocket.on('data', function(data) {
      return clientSocket.write(data);
    });
    clientSocket.on('data', function(data) {
      buffers[buffers.length] = data;
      if (connected && !closed) {
        return proxySocket.write(data);
      }
    });
    clientSocket.on('close', function(did_error) {
      return proxySocket.end();
    });
    return proxySocket.on('close', function(did_error) {
      closed = true;
      return clientSocket.end();
    });
  });
  forwardServer.listen(config['proxy-port'], function() {
    return logX(ltGreen, "Proxy server bound on port " + config['proxy-port']);
  });
  return setInterval(function() {
    return hideMyAssGrabber.update(updateProxy);
  }, config['rotateInterval']);
};
